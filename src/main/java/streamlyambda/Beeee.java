package streamlyambda;

import java.util.List;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Beeee {

    public static void main(String[] args) {

        Beeee beeee = new Beeee();

        int[] arrInt = {3, 7};

        System.out.println(beeee.runn(3, 7));
        System.out.println(beeee.runn2(7));
        System.out.println(beeee.runn3(15));
        System.out.println(beeee.runn4(5));
        System.out.println(beeee.createNumber(5));


    }

    public int runn(int a, int b) {

        Stream<Integer> mySream = Stream.of(a, b);

        return mySream.reduce(0, Integer::sum); //todo сложить


    }

    public int runn2(int a) {  //Требуется посчитать сумму целых чисел, расположенных между числами 1 и N включительно.

        return IntStream.range(1, a).
                reduce(0, Integer::sum);

    }


    public int runn3(int a) {  // Возведение в квадрат

        Stream<Integer> myStream = Stream.of(a);

        int result = myStream.map(x -> x * x).
                findFirst().
                orElse(0);

        return result;

    }


    public int razbivkaChislaSPerevorotom(int a) {

//String str = String.valueOf(a);
//IntStream myStream = str.chars().map(Character::getNumericValue);

        Stream<Integer> myStream = Stream.iterate(a, n -> n / 10) //выводит 487 затем 48 затем 4  - сначал ориг затем ориг деленный на 10 это 48 затем результат деленный на 10 это 4 затем уже все так же ну выходят нули

                .map(n -> n % 10) // оставляем только остаток от деления на 10 - таким образом остаеться 784 зеркально входному а далеее куча нулей
                .limit(String.valueOf(a).length()); // ограничиваем проход по количеству цифр в пришедшем числе что бы не было бесконечное количество нулей далее


        myStream.forEach(System.out::println);


        return 1;


    }


    public int runn4(int a) { //  В свободное время одноклассники Вася и Петя любят играть в различные логические игры: морской бой, крестики-нолики, шахматы, шашки и многое другое. Ребята уже испробовали и поиграли во всевозможные классические игры подобного рода, включая компьютерные. Однажды им захотелось сыграть во что-нибудь новое, но ничего подходящего найти не удалось. Тогда Петя придумал следующую игру «Угадайка»: Играют двое участников. Первый загадывает любое трехзначное число, такое что первая и последняя цифры отличаются друг от друга более чем на единицу. Далее загадавший число игрок переворачивает загаданное число, меняя первую и последнюю цифры местами, таким образом получая еще одно число. Затем из максимального из полученных двух чисел вычитается минимальное. Задача второго игрока – угадать по первой цифре полученного в результате вычитания числа само это число. Например, если Вася загадал число 487, то перестановкой первой и последней цифры он получит число 784. После чего ему придется вычесть из 784 число 487, в результате чего получится число 297, которое и должен отгадать Петя по указанной первой цифре «2», взятой из этого числа. Петя успевает лучше Васи по математике, поэтому практически всегда выигрывает в играх такого типа. Но в данном случае Петя схитрил и специально придумал такую игру, в которой он не проиграет Васе в любом случае. Дело в том, что придуманная Петей игра имеет выигрышную стратегию, которая заключается в следующем: искомое число всегда является трехзначным и вторая его цифра всегда равна девяти, а для получения значения последней достаточно отнять от девяти первую, т.е. в рассмотренном выше случае последняя цифра равна 9-2=7. Помогите Пете еще упростить процесс отгадывания числа по заданной его первой цифре, написав соответствующую программу.

IntStream myIntStream = IntStream.of(a);

int ress = myIntStream
        .map(x -> x * 100 + 90 + (9-x))
        .findFirst()
        .orElse(0);


        return ress;
    }

    public int createNumber(int a) {
        IntStream myIntStream = IntStream.of(a);
        int result = myIntStream.flatMap(n -> IntStream.of(n, 9, 9 - n))//flatMap() принимает каждый элемент из myIntStream и преобразует его в новый стрим, содержащий три элемента: само число n, число 9 и разницу между 9 и числом n.
                .peek(System.out::println)
                .reduce((n1, n2) -> n1 * 10 + n2) // берет первое число умножает на 10 прибавляет второе - затем вновь берет результат умножает на 10 прибавляет третее число и .д. если просто то склеивает два и более десятичных числа
                .orElse(0);
        return result;
    }


}
